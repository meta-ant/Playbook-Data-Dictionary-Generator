<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playbook Data Dictionary Generator (AI Enhanced)</title>

    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1C1134 0%, #292D66 50%, #6572D8 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #1C1134;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .ai-badge {
            display: inline-block;
            background: linear-gradient(135deg, #6572D8, #1C1134);
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 10px;
            vertical-align: middle;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .upload-section {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .dropzone {
            border: 3px dashed #6572D8;
            border-radius: 8px;
            padding: 30px 20px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dropzone:hover, .dropzone.drag-over {
            background: #e8f0fe;
            border-color: #1C1134;
        }

        .dropzone-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .dropzone-text {
            font-size: 16px;
            color: #1C1134;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .dropzone-subtext {
            font-size: 14px;
            color: #666;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: #1C1134;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

        .btn:hover {
            background: #292D66;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
        }

        .file-result {
            background: white;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .file-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .file-name {
            font-size: 20px;
            font-weight: 700;
            color: #1C1134;
        }

        .status {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
        }

        .status.processing {
            background: #fff3cd;
            color: #856404;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
        }

        .preview-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .preview-stat {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #6572D8;
        }

        .preview-stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .preview-stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #1C1134;
        }

        .event-list {
            margin-top: 15px;
        }

        .event-list-title {
            font-size: 14px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
        }

        .event-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .event-tag {
            background: #6572D8;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .error-message {
            color: #721c24;
            background: #f8d7da;
            padding: 12px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .clear-btn {
            background: #6c757d;
            margin-left: 10px;
        }

        .clear-btn:hover {
            background: #5a6268;
        }

        .footer {
            text-align: center;
            color: white;
            padding: 15px;
            font-size: 14px;
            opacity: 0.8;
        }

        .name-input-section {
            margin-bottom: 15px;
        }

        .name-input-label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #1C1134;
            margin-bottom: 8px;
        }

        .name-input {
            width: 100%;
            max-width: 500px;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #6572D8;
            border-radius: 6px;
            font-family: 'IBM Plex Sans', sans-serif;
        }

        .name-input:focus {
            outline: none;
            border-color: #1C1134;
        }

        .name-input-hint {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        /* AI-specific styles */
        .ai-options {
            background: #f8f9fa;
            border: 2px solid #6572D8;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .ai-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .ai-title {
            font-size: 16px;
            font-weight: 700;
            color: #1C1134;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 600;
        }

        .ai-status.available {
            background: #d4edda;
            color: #155724;
        }

        .ai-status.fallback {
            background: #fff3cd;
            color: #856404;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-container label {
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }

        .ai-info {
            font-size: 13px;
            color: #666;
            line-height: 1.5;
            margin-top: 10px;
        }

        .progress-container {
            display: none;
            margin-top: 15px;
        }

        .progress-container.active {
            display: block;
        }

        .progress-label {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
        }

        .progress-bar {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #6572D8, #1C1134);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Playbook Data Dictionary Generator <span class="ai-badge">AI ENHANCED</span></h1>
            <p class="subtitle">Upload your playbook.yaml files to generate comprehensive Excel data dictionaries with AI-powered descriptions</p>
        </div>

        <div class="upload-section">
            <div class="name-input-section">
                <label class="name-input-label" for="playbookNameInput">Playbook Name (Optional)</label>
                <input type="text" id="playbookNameInput" class="name-input" placeholder="e.g., MetaRouter Production">
                <div class="name-input-hint">This name will appear in the Playbook column and filename. If left blank, the filename will be used.</div>
            </div>

            <div class="ai-options">
                <div class="ai-header">
                    <div class="ai-title">
                        ü§ñ AI Description Generator
                    </div>
                    <div id="aiStatus" class="ai-status fallback">Using Smart Templates</div>
                </div>

                <div class="checkbox-container">
                    <input type="checkbox" id="aiEnabled" checked>
                    <label for="aiEnabled">Generate AI descriptions (experimental)</label>
                </div>

                <div class="ai-info">
                    When enabled, the tool will generate 2-3 sentence descriptions explaining what each mapping does.
                    Chrome users with AI features enabled will get enhanced AI-powered descriptions.
                    Other browsers will use smart template-based descriptions.
                    <strong>Note: AI-generated descriptions should be verified for accuracy.</strong>
                </div>

                <div id="progressContainer" class="progress-container">
                    <div class="progress-label" id="progressLabel">Generating descriptions...</div>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill" style="width: 0%">0%</div>
                    </div>
                </div>
            </div>

            <div class="dropzone" id="dropzone">
                <div class="dropzone-icon">üìÑ</div>
                <div class="dropzone-text">Drag & Drop playbook.yaml files here</div>
                <div class="dropzone-subtext">or click to browse (supports multiple files)</div>
            </div>
            <input type="file" id="fileInput" class="file-input" accept=".yaml,.yml" multiple>
            <div style="text-align: center;">
                <button class="btn" onclick="document.getElementById('fileInput').click()">Browse Files</button>
                <button class="btn clear-btn" id="clearBtn" onclick="clearResults()" style="display: none;">Clear All</button>
            </div>
        </div>

        <div class="results-section" id="resultsSection">
            <div id="results"></div>
        </div>

        <div class="footer">
            Playbook Data Dictionary Generator (AI Enhanced) | MetaRouter
        </div>
    </div>

    <script>
        // AI State Management
        let aiSession = null;
        let aiAvailable = false;

        // Check for Chrome Built-in AI on page load
        async function initializeAI() {
            try {
                if ('ai' in window && 'languageModel' in window.ai) {
                    const capabilities = await window.ai.languageModel.capabilities();
                    if (capabilities.available === 'readily') {
                        aiSession = await window.ai.languageModel.create({
                            systemPrompt: 'You are a data mapping expert. Explain data transformations clearly and concisely in 2-3 sentences.'
                        });
                        aiAvailable = true;
                        document.getElementById('aiStatus').textContent = 'AI Available ‚úì';
                        document.getElementById('aiStatus').className = 'ai-status available';
                        console.log('Chrome Built-in AI initialized successfully');
                        return true;
                    }
                }
            } catch (error) {
                console.log('Chrome Built-in AI not available, using fallback:', error.message);
            }
            return false;
        }

        // Initialize AI on page load
        initializeAI();

        // Save AI preference to localStorage
        document.getElementById('aiEnabled').addEventListener('change', (e) => {
            localStorage.setItem('aiDescriptionsEnabled', e.target.checked);
        });

        // Load AI preference from localStorage
        const savedPreference = localStorage.getItem('aiDescriptionsEnabled');
        if (savedPreference !== null) {
            document.getElementById('aiEnabled').checked = savedPreference === 'true';
        }

        // AI Description Generator
        class AIDescriptionGenerator {
            static async generateDescription(mappingData) {
                const mapping = mappingData.mapping;
                const eventType = mappingData.event_type;

                // Check if AI descriptions are enabled
                if (!document.getElementById('aiEnabled').checked) {
                    return '';
                }

                // Try Chrome AI first
                if (aiAvailable && aiSession) {
                    try {
                        const description = await this.generateWithChromeAI(mapping, eventType);
                        if (description) return description;
                    } catch (error) {
                        console.warn('Chrome AI generation failed, using fallback:', error);
                    }
                }

                // Fallback to template-based descriptions
                return this.generateWithTemplate(mapping, eventType);
            }

            static async generateWithChromeAI(mapping, eventType) {
                const prompt = this.buildPrompt(mapping, eventType);
                try {
                    const response = await aiSession.prompt(prompt);
                    return response.trim();
                } catch (error) {
                    console.error('Chrome AI error:', error);
                    return null;
                }
            }

            static buildPrompt(mapping, eventType) {
                const inputKey = mapping.inputKey || '(none)';
                const outputKey = mapping.outputKey || '(none)';
                const transforms = mapping.transforms ? JSON.stringify(mapping.transforms) : 'none';
                const enrichments = [];

                if (mapping.staticString !== undefined) enrichments.push(`static string: "${mapping.staticString}"`);
                if (mapping.staticBool !== undefined) enrichments.push(`static bool: ${mapping.staticBool}`);
                if (mapping.staticInt !== undefined) enrichments.push(`static int: ${mapping.staticInt}`);
                if (mapping.timestamp) enrichments.push(`timestamp: ${mapping.timestamp}`);

                const enrichmentText = enrichments.length > 0 ? enrichments.join(', ') : 'none';
                const defaults = [];

                if (mapping.defaultString !== undefined) defaults.push(`default string: "${mapping.defaultString}"`);
                if (mapping.defaultBool !== undefined) defaults.push(`default bool: ${mapping.defaultBool}`);
                if (mapping.defaultInt !== undefined) defaults.push(`default int: ${mapping.defaultInt}`);

                const defaultText = defaults.length > 0 ? defaults.join(', ') : 'none';

                return `Explain this data mapping in 2-3 sentences:
Event Type: ${eventType}
Input: ${inputKey}
Output: ${outputKey}
Transforms: ${transforms}
Enrichments: ${enrichmentText}
Defaults: ${defaultText}

Describe what this mapping does, why it's needed, and any important technical details. Be specific and technical.`;
            }

            static generateWithTemplate(mapping, eventType) {
                const inputKey = mapping.inputKey || '';
                const outputKey = mapping.outputKey || '';

                // Handle enrichments (static values)
                if (inputKey === '(enrichment)') {
                    if (mapping.staticString !== undefined) {
                        return this.getEnrichmentContext(outputKey, mapping.staticString);
                    }
                    if (mapping.staticBool !== undefined) {
                        return this.getEnrichmentContext(outputKey, mapping.staticBool);
                    }
                    if (mapping.staticInt !== undefined) {
                        return this.getEnrichmentContext(outputKey, mapping.staticInt);
                    }
                    if (mapping.timestamp) {
                        return `Provides event timing information required by the destination platform.`;
                    }
                }

                // Handle hashing transforms
                if (mapping.transforms) {
                    const hashTransform = mapping.transforms.find(t => t.toHash);
                    if (hashTransform) {
                        return `Protects PII while enabling audience matching. ${this.getHashContext(outputKey)}`;
                    }

                    // Handle string transforms
                    const stringTransform = mapping.transforms.find(t => t.modifyString);
                    if (stringTransform) {
                        return this.getStringTransformReason(stringTransform.modifyString, outputKey);
                    }

                    // Handle Lua expressions
                    const luaTransform = mapping.transforms.find(t => t.expression && t.expression.body);
                    if (luaTransform) {
                        const luaBody = luaTransform.expression.body;
                        if (luaBody.includes('SUM') && luaBody.includes('MAP')) {
                            return `Calculates total transaction value for conversion tracking and ROAS optimization.`;
                        }
                        if (luaBody.includes('MAP') && luaBody.includes('function')) {
                            return `Restructures product data into the format required by the destination platform's API.`;
                        }
                        if (luaBody.includes('return {')) {
                            return `Wraps scalar value in array to meet destination API requirements.`;
                        }
                        return `Custom business logic transformation for complex data processing needs.`;
                    }

                    // Handle pluck transforms
                    const pluckTransform = mapping.transforms.find(t => t.pluckValues);
                    if (pluckTransform) {
                        const extractKey = pluckTransform.pluckValues.extractKey || 'unknown';
                        return `Flattens product array to simple list of ${extractKey}s for destination platform.`;
                    }

                    // Handle type conversions
                    const scalarTransform = mapping.transforms.find(t => t.toScalar);
                    if (scalarTransform) {
                        return `Type conversion to meet destination API schema requirements.`;
                    }
                }

                // Handle default values
                if (mapping.defaultString !== undefined || mapping.defaultBool !== undefined || mapping.defaultInt !== undefined) {
                    const defaultVal = mapping.defaultString || mapping.defaultBool || mapping.defaultInt;
                    return `Ensures destination always receives a valid value, preventing data quality issues.`;
                }

                // Generic mapping description based on output context
                if (outputKey) {
                    return this.getFieldContext(outputKey);
                }

                // Fallback for edge cases
                return '';
            }

            static getEnrichmentContext(outputKey, value) {
                // Action source
                if (outputKey.includes('action_source')) {
                    return `Identifies traffic source for attribution. Required by platform for proper event categorization.`;
                }
                // Content type
                if (outputKey.includes('content_type')) {
                    return `Categorizes the type of content being tracked (product, article, etc.) for reporting.`;
                }
                // Event name mappings
                if (outputKey.includes('event_name')) {
                    return `Maps to destination platform's standard event taxonomy for proper tracking.`;
                }
                // Generic
                return `Static value ensuring consistent metadata across all events.`;
            }

            static getHashContext(outputKey) {
                if (outputKey.includes('em') || outputKey.includes('email')) {
                    return `Email hashing required by Facebook/Google for privacy-compliant matching.`;
                }
                if (outputKey.includes('ph') || outputKey.includes('phone')) {
                    return `Phone hashing required for privacy-compliant user matching.`;
                }
                return `One-way encryption for privacy-compliant audience matching.`;
            }

            static getStringTransformReason(transform, outputKey) {
                if (transform === 'uppercase') {
                    if (outputKey.includes('currency')) {
                        return `ISO 4217 standard requires uppercase currency codes (USD, EUR, etc.).`;
                    }
                    return `Destination platform requires uppercase formatting.`;
                }
                if (transform === 'lowercase') {
                    return `Normalizes to lowercase for consistent destination formatting.`;
                }
                return `String normalization for destination compatibility.`;
            }

            static getFieldContext(outputKey) {
                // User identification
                if (outputKey.includes('external_id') || outputKey.includes('user_id')) {
                    return `Links events to user identity for cross-session attribution and audience building.`;
                }
                // Deduplication
                if (outputKey.includes('event_id')) {
                    return `Prevents duplicate event counting in destination platform.`;
                }
                // URLs
                if (outputKey.includes('url') || outputKey.includes('page')) {
                    return `Provides page context for attribution and conversion funnel analysis.`;
                }
                // User agent / IP
                if (outputKey.includes('user_agent') || outputKey.includes('ip')) {
                    return `Browser/device fingerprinting for improved user matching accuracy.`;
                }
                // Products/content
                if (outputKey.includes('product') || outputKey.includes('content')) {
                    return `Product/content data for dynamic remarketing and catalog sales optimization.`;
                }
                // Value/revenue
                if (outputKey.includes('value') || outputKey.includes('revenue')) {
                    return `Transaction value for conversion tracking and ROAS calculation.`;
                }
                // Currency
                if (outputKey.includes('currency')) {
                    return `Currency code for accurate cross-currency revenue reporting.`;
                }
                // Generic
                return `Standard field mapping for destination platform compatibility.`;
            }
        }

        // Playbook Parser Class
        class PlaybookParser {
            constructor(filename, yamlContent, customName = null) {
                this.filename = filename;
                this.data = jsyaml.load(yamlContent);
                this.playbookName = customName || this.getPlaybookName();
            }

            getPlaybookName() {
                // Extract name from filename if no custom name provided
                return this.filename.replace('.yaml', '').replace('.yml', '');
            }

            extractMappings() {
                const allMappings = [];

                // Extract global mappings
                if (this.data.global && this.data.global.mappings) {
                    this.data.global.mappings.forEach(mapping => {
                        allMappings.push({
                            playbook: this.playbookName,
                            event_type: 'GLOBAL (All Events)',
                            mapping: mapping
                        });
                    });
                }

                // Extract global enrichments
                if (this.data.global && this.data.global.enrichments) {
                    this.data.global.enrichments.forEach(enrichment => {
                        allMappings.push({
                            playbook: this.playbookName,
                            event_type: 'GLOBAL (All Events)',
                            mapping: {
                                outputKey: enrichment.outputKey,
                                inputKey: '(enrichment)',
                                staticString: enrichment.staticString,
                                staticBool: enrichment.staticBool,
                                staticInt: enrichment.staticInt,
                                timestamp: enrichment.timestamp
                            }
                        });
                    });
                }

                // Extract global spreadings
                if (this.data.global && this.data.global.spreadings) {
                    this.data.global.spreadings.forEach(spreading => {
                        allMappings.push({
                            playbook: this.playbookName,
                            event_type: 'GLOBAL (All Events)',
                            mapping: {
                                outputKey: spreading.outputKey || '(spreading)',
                                inputKey: spreading.inputKey || '(spreading)',
                                ...spreading
                            }
                        });
                    });
                }

                // Extract global expressions
                if (this.data.global && this.data.global.expressions) {
                    this.data.global.expressions.forEach(expression => {
                        allMappings.push({
                            playbook: this.playbookName,
                            event_type: 'GLOBAL (All Events)',
                            mapping: {
                                outputKey: expression.outputKey || '(expression)',
                                inputKey: '(expression)',
                                expression: expression.expression
                            }
                        });
                    });
                }

                // Extract default mappings
                if (this.data.default && this.data.default.mappings) {
                    this.data.default.mappings.forEach(mapping => {
                        allMappings.push({
                            playbook: this.playbookName,
                            event_type: 'DEFAULT (Unmapped Events)',
                            mapping: mapping
                        });
                    });
                }

                // Extract default enrichments
                if (this.data.default && this.data.default.enrichments) {
                    this.data.default.enrichments.forEach(enrichment => {
                        allMappings.push({
                            playbook: this.playbookName,
                            event_type: 'DEFAULT (Unmapped Events)',
                            mapping: {
                                outputKey: enrichment.outputKey,
                                inputKey: '(enrichment)',
                                staticString: enrichment.staticString,
                                staticBool: enrichment.staticBool,
                                staticInt: enrichment.staticInt,
                                timestamp: enrichment.timestamp
                            }
                        });
                    });
                }

                // Extract default spreadings
                if (this.data.default && this.data.default.spreadings) {
                    this.data.default.spreadings.forEach(spreading => {
                        allMappings.push({
                            playbook: this.playbookName,
                            event_type: 'DEFAULT (Unmapped Events)',
                            mapping: {
                                outputKey: spreading.outputKey || '(spreading)',
                                inputKey: spreading.inputKey || '(spreading)',
                                ...spreading
                            }
                        });
                    });
                }

                // Extract default expressions
                if (this.data.default && this.data.default.expressions) {
                    this.data.default.expressions.forEach(expression => {
                        allMappings.push({
                            playbook: this.playbookName,
                            event_type: 'DEFAULT (Unmapped Events)',
                            mapping: {
                                outputKey: expression.outputKey || '(expression)',
                                inputKey: '(expression)',
                                expression: expression.expression
                            }
                        });
                    });
                }

                // Extract event-specific mappings, enrichments, spreadings, and expressions
                if (this.data.eventSpecific) {
                    Object.entries(this.data.eventSpecific).forEach(([eventName, eventConfig]) => {
                        // Extract mappings
                        if (eventConfig.mappings && eventConfig.mappings.length > 0) {
                            eventConfig.mappings.forEach(mapping => {
                                allMappings.push({
                                    playbook: this.playbookName,
                                    event_type: eventName,
                                    mapping: mapping
                                });
                            });
                        }

                        // Extract enrichments
                        if (eventConfig.enrichments && eventConfig.enrichments.length > 0) {
                            eventConfig.enrichments.forEach(enrichment => {
                                allMappings.push({
                                    playbook: this.playbookName,
                                    event_type: eventName,
                                    mapping: {
                                        outputKey: enrichment.outputKey,
                                        inputKey: '(enrichment)',
                                        staticString: enrichment.staticString,
                                        staticBool: enrichment.staticBool,
                                        staticInt: enrichment.staticInt,
                                        timestamp: enrichment.timestamp
                                    }
                                });
                            });
                        }

                        // Extract spreadings
                        if (eventConfig.spreadings && eventConfig.spreadings.length > 0) {
                            eventConfig.spreadings.forEach(spreading => {
                                allMappings.push({
                                    playbook: this.playbookName,
                                    event_type: eventName,
                                    mapping: {
                                        outputKey: spreading.outputKey || '(spreading)',
                                        inputKey: spreading.inputKey || '(spreading)',
                                        ...spreading
                                    }
                                });
                            });
                        }

                        // Extract expressions
                        if (eventConfig.expressions && eventConfig.expressions.length > 0) {
                            eventConfig.expressions.forEach(expression => {
                                allMappings.push({
                                    playbook: this.playbookName,
                                    event_type: eventName,
                                    mapping: {
                                        outputKey: expression.outputKey || '(expression)',
                                        inputKey: '(expression)',
                                        expression: expression.expression
                                    }
                                });
                            });
                        }

                        // If event has no configurations at all, add placeholder
                        const hasConfig = (eventConfig.mappings && eventConfig.mappings.length > 0) ||
                                         (eventConfig.enrichments && eventConfig.enrichments.length > 0) ||
                                         (eventConfig.spreadings && eventConfig.spreadings.length > 0) ||
                                         (eventConfig.expressions && eventConfig.expressions.length > 0);

                        if (!hasConfig) {
                            allMappings.push({
                                playbook: this.playbookName,
                                event_type: eventName,
                                mapping: {
                                    outputKey: '(no configurations)',
                                    inputKey: '(no configurations)'
                                }
                            });
                        }
                    });
                }

                return allMappings;
            }

            extractGlobalMappings() {
                const globalMappings = [];

                // Extract global mappings
                if (this.data.global && this.data.global.mappings) {
                    this.data.global.mappings.forEach(mapping => {
                        globalMappings.push({
                            playbook: this.playbookName,
                            event_type: 'GLOBAL (All Events)',
                            mapping: mapping
                        });
                    });
                }

                // Extract global enrichments
                if (this.data.global && this.data.global.enrichments) {
                    this.data.global.enrichments.forEach(enrichment => {
                        globalMappings.push({
                            playbook: this.playbookName,
                            event_type: 'GLOBAL (All Events)',
                            mapping: {
                                outputKey: enrichment.outputKey,
                                inputKey: '(enrichment)',
                                staticString: enrichment.staticString,
                                staticBool: enrichment.staticBool,
                                staticInt: enrichment.staticInt,
                                timestamp: enrichment.timestamp
                            }
                        });
                    });
                }

                // Extract global spreadings
                if (this.data.global && this.data.global.spreadings) {
                    this.data.global.spreadings.forEach(spreading => {
                        globalMappings.push({
                            playbook: this.playbookName,
                            event_type: 'GLOBAL (All Events)',
                            mapping: {
                                outputKey: spreading.outputKey || '(spreading)',
                                inputKey: spreading.inputKey || '(spreading)',
                                ...spreading
                            }
                        });
                    });
                }

                // Extract global expressions
                if (this.data.global && this.data.global.expressions) {
                    this.data.global.expressions.forEach(expression => {
                        globalMappings.push({
                            playbook: this.playbookName,
                            event_type: 'GLOBAL (All Events)',
                            mapping: {
                                outputKey: expression.outputKey || '(expression)',
                                inputKey: '(expression)',
                                expression: expression.expression
                            }
                        });
                    });
                }

                return globalMappings;
            }

            extractFilters() {
                const filters = {
                    global: [],
                    default: [],
                    eventSpecific: {}
                };

                // Extract global filters
                if (this.data.global && this.data.global.filters) {
                    filters.global = this.data.global.filters;
                }

                // Extract default filters
                if (this.data.default && this.data.default.filters) {
                    filters.default = this.data.default.filters;
                }

                // Extract event-specific filters
                if (this.data.eventSpecific) {
                    Object.entries(this.data.eventSpecific).forEach(([eventName, eventConfig]) => {
                        if (eventConfig.filters) {
                            filters.eventSpecific[eventName] = eventConfig.filters;
                        }
                    });
                }

                return filters;
            }
        }

        // Mapping Formatter Class
        class MappingFormatter {
            static formatTransforms(mapping) {
                if (!mapping.transforms) return '‚àÖ';

                const formatted = [];
                mapping.transforms.forEach(transform => {
                    if (transform.toHash) {
                        formatted.push(`Hash: ${transform.toHash}`);
                    } else if (transform.modifyString) {
                        formatted.push(`String: ${transform.modifyString}`);
                    } else if (transform.expression) {
                        const expr = transform.expression;
                        if (expr.body) {
                            formatted.push(`Lua: ${expr.body}`);
                        } else {
                            formatted.push(`Expression: ${expr}`);
                        }
                    } else if (transform.pluckValues) {
                        const key = transform.pluckValues.extractKey || 'unknown';
                        formatted.push(`Pluck: ${key}`);
                    } else if (transform.toScalar) {
                        formatted.push(`Convert to: ${transform.toScalar}`);
                    } else if (transform.filterArray) {
                        formatted.push('Filter array');
                    } else if (transform.toArray) {
                        formatted.push('Convert to array');
                    } else {
                        formatted.push(JSON.stringify(transform));
                    }
                });

                return formatted.join('\n') || '‚àÖ';
            }

            static formatEnrichments(mapping) {
                const enrichments = [];

                if (mapping.staticString !== undefined) {
                    enrichments.push(`Static: "${mapping.staticString}"`);
                }
                if (mapping.staticBool !== undefined) {
                    enrichments.push(`Static: ${mapping.staticBool}`);
                }
                if (mapping.staticInt !== undefined) {
                    enrichments.push(`Static: ${mapping.staticInt}`);
                }
                if (mapping.timestamp) {
                    enrichments.push(`Timestamp: ${mapping.timestamp}`);
                }

                return enrichments.join('\n') || '‚àÖ';
            }

            static formatDefaults(mapping) {
                const defaults = [];

                if (mapping.defaultString !== undefined) {
                    defaults.push(`Default: "${mapping.defaultString}"`);
                }
                if (mapping.defaultBool !== undefined) {
                    defaults.push(`Default: ${mapping.defaultBool}`);
                }
                if (mapping.defaultInt !== undefined) {
                    defaults.push(`Default: ${mapping.defaultInt}`);
                }

                return defaults.join('\n') || '‚àÖ';
            }

            static formatFilters(filterArray) {
                if (!filterArray || filterArray.length === 0) {
                    return '‚àÖ';
                }

                const formatted = [];
                filterArray.forEach(filter => {
                    if (filter.byEventNames) {
                        const action = filter.byEventNames.action;
                        const events = filter.byEventNames.events || [];
                        const eventList = events.map(e => e === '' ? 'all events' : e).join(', ');
                        formatted.push(`${action.toUpperCase()}: ${eventList}`);
                    } else if (filter.byConditions) {
                        const action = filter.byConditions.action;
                        const when = filter.byConditions.when;

                        if (when && when.matchesAny) {
                            const conditions = when.matchesAny.conditions || [];
                            const condDesc = this.formatConditions(conditions);
                            formatted.push(`${action.toUpperCase()} when ANY: ${condDesc}`);
                        } else if (when && when.matchesAll) {
                            const conditions = when.matchesAll.conditions || [];
                            const condDesc = this.formatConditions(conditions);
                            formatted.push(`${action.toUpperCase()} when ALL: ${condDesc}`);
                        } else {
                            formatted.push(`${action.toUpperCase()} by conditions`);
                        }
                    } else {
                        formatted.push(JSON.stringify(filter));
                    }
                });

                return formatted.join('\n');
            }

            static formatConditions(conditions) {
                const parts = [];
                conditions.forEach(cond => {
                    if (cond.inputPathExists) {
                        parts.push(`${cond.inputPathExists.inputPath} exists`);
                    } else if (cond.stringEqual) {
                        const path = cond.stringEqual.inputPath;
                        const value = cond.stringEqual.value;
                        parts.push(`${path} = "${value}"`);
                    } else {
                        parts.push(JSON.stringify(cond));
                    }
                });
                return parts.join(', ');
            }
        }

        // Excel Generator Class
        class ExcelGenerator {
            constructor() {
                this.workbook = new ExcelJS.Workbook();
            }

            createReadmeSheet() {
                const worksheet = this.workbook.addWorksheet('README');

                // Set column widths
                worksheet.columns = [
                    { width: 80 }
                ];

                // Title
                let row = worksheet.addRow(['Playbook Data Dictionary Generator (AI Enhanced)']);
                row.font = { size: 18, bold: true, color: { argb: 'FF1C1134' } };
                row.height = 30;
                worksheet.addRow([]);

                // What it does
                row = worksheet.addRow(['What is this tool?']);
                row.font = { size: 14, bold: true, color: { argb: 'FF1C1134' } };
                worksheet.addRow(['This AI-enhanced tool parses playbook.yaml files and generates a comprehensive data dictionary showing inputs, outputs, transformations, enrichments, and default values for each event type. The Description column contains AI-generated explanations of what each mapping does.']);
                worksheet.addRow([]);

                // AI Notice
                row = worksheet.addRow(['ü§ñ AI-Generated Descriptions']);
                row.font = { size: 14, bold: true, color: { argb: 'FF6572D8' } };
                worksheet.addRow(['The Description column contains automatically generated explanations created by AI or smart templates. Chrome users with AI features enabled receive enhanced AI-powered descriptions, while other browsers use intelligent template-based descriptions. These descriptions help you understand the purpose and technical details of each mapping at a glance.']);
                worksheet.addRow([]);

                // Beta notice
                row = worksheet.addRow(['‚ö†Ô∏è Beta Tool Notice']);
                row.font = { size: 14, bold: true, color: { argb: 'FFFF0000' } };
                worksheet.addRow(['This is a BETA tool. Please verify both the mappings AND the AI-generated descriptions against your actual playbook.yaml file to ensure accuracy. AI descriptions should be treated as helpful guides, not absolute truth. If you find discrepancies, please report them.']);
                worksheet.addRow([]);

                // How to use
                row = worksheet.addRow(['Understanding the Sheets']);
                row.font = { size: 14, bold: true, color: { argb: 'FF1C1134' } };
                worksheet.addRow([]);

                worksheet.addRow(['Summary Sheet:']);
                row.font = { bold: true };
                worksheet.addRow(['‚Ä¢ Event Type: The name of each event in your playbook']);
                worksheet.addRow(['‚Ä¢ Mappings: Number of field mappings for that event']);
                worksheet.addRow([]);

                worksheet.addRow(['Event Sheets:']);
                row.font = { bold: true };
                worksheet.addRow(['Each event sheet is divided into 3 sections to show you the complete picture:']);
                worksheet.addRow([]);

                worksheet.addRow(['SECTION 1: FILTERS']);
                row = worksheet.getRow(worksheet.rowCount);
                row.font = { bold: true };
                worksheet.addRow(['Shows which filters apply to this event:']);
                worksheet.addRow(['‚Ä¢ Global Filters: Apply to ALL events before processing']);
                worksheet.addRow(['‚Ä¢ Event Filters: Apply only to this specific event']);
                worksheet.addRow(['‚Ä¢ Filters determine whether an event gets processed at all']);
                worksheet.addRow([]);

                worksheet.addRow(['SECTION 2: EVENT-SPECIFIC MAPPINGS']);
                row = worksheet.getRow(worksheet.rowCount);
                row.font = { bold: true };
                worksheet.addRow(['Shows mappings that apply ONLY to this event. Columns:']);
                worksheet.addRow(['‚Ä¢ Output Key: The destination field where data is sent']);
                worksheet.addRow(['‚Ä¢ Input Key: The source field where data comes from']);
                worksheet.addRow(['‚Ä¢ Transforms: Operations applied to the data (e.g., hashing, uppercase, Lua)']);
                worksheet.addRow(['‚Ä¢ Enrichments: Static values or timestamps added to the output']);
                worksheet.addRow(['‚Ä¢ Defaults: Default values used when the input is missing']);
                worksheet.addRow(['‚Ä¢ Description or Description (AI Generated): Explains WHY this mapping exists and its business purpose. Column header indicates if AI was used.']);
                worksheet.addRow(['‚Ä¢ Playbook: The name of the playbook']);
                worksheet.addRow([]);

                worksheet.addRow(['SECTION 3: GLOBAL MAPPINGS']);
                row = worksheet.getRow(worksheet.rowCount);
                row.font = { bold: true };
                worksheet.addRow(['Shows mappings that apply to ALL events (duplicated from GLOBAL sheet for convenience)']);
                worksheet.addRow(['These mappings are applied to EVERY event in addition to event-specific mappings.']);
                worksheet.addRow([]);

                // Special notes
                row = worksheet.addRow(['Special Indicators']);
                row.font = { size: 14, bold: true, color: { argb: 'FF1C1134' } };
                worksheet.addRow([]);
                worksheet.addRow(['‚Ä¢ ‚àÖ (empty set): Indicates the field is intentionally empty or not applicable']);
                worksheet.addRow(['‚Ä¢ "(enrichment)" in Input Key: This mapping only adds a static value, no input field']);
                worksheet.addRow(['‚Ä¢ "input: see transform" in Input Key: The entire event object is used; check the Transforms column for logic']);
                worksheet.addRow([]);

                // Contact
                row = worksheet.addRow(['Questions or Issues?']);
                row.font = { size: 14, bold: true, color: { argb: 'FF1C1134' } };
                worksheet.addRow(['Contact your MetaRouter representative for support.']);
                worksheet.addRow([]);

                // Apply wrap text to all cells
                worksheet.eachRow((row) => {
                    row.eachCell((cell) => {
                        cell.alignment = { vertical: 'top', wrapText: true };
                    });
                });
            }

            createSummarySheet(eventData) {
                const worksheet = this.workbook.addWorksheet('Summary');

                // Add header row - simplified to Event Type and Mappings
                worksheet.columns = [
                    { header: 'Event Type', key: 'eventType', width: 35 },
                    { header: 'Mappings', key: 'mappings', width: 15 }
                ];

                // Style header row
                const headerRow = worksheet.getRow(1);
                headerRow.eachCell((cell) => {
                    cell.fill = {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FF1C1134' }
                    };
                    cell.font = {
                        color: { argb: 'FFFFFFFF' },
                        bold: true,
                        size: 11
                    };
                    cell.alignment = { horizontal: 'center', vertical: 'middle' };
                    cell.border = {
                        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                    };
                });

                // Add data rows
                Object.keys(eventData).sort().forEach(eventType => {
                    const mappingCount = eventData[eventType].length;
                    const row = worksheet.addRow({
                        eventType: eventType,
                        mappings: mappingCount
                    });

                    // Style data cells
                    row.eachCell((cell) => {
                        cell.border = {
                            top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                            left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                            bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                            right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                        };
                        cell.alignment = { vertical: 'top', wrapText: true };
                    });
                });
            }

            async createEventSheet(eventType, mappings, filters, globalMappings, aiEnabled) {
                const sheetName = eventType.replace('/', '-').substring(0, 31);
                const worksheet = this.workbook.addWorksheet(sheetName);

                // Set column widths for all sections - increased Description column width
                worksheet.columns = [
                    { width: 30 }, { width: 30 }, { width: 25 }, { width: 20 }, { width: 15 }, { width: 50 }, { width: 20 }
                ];

                let currentRow = 1;

                // SECTION 1: FILTERS
                const filterHeader = worksheet.getRow(currentRow);
                filterHeader.getCell(1).value = 'FILTERS APPLIED TO THIS EVENT';
                filterHeader.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1C1134' } };
                filterHeader.getCell(1).font = { color: { argb: 'FFFFFFFF' }, bold: true, size: 12 };
                filterHeader.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
                worksheet.mergeCells(currentRow, 1, currentRow, 7);
                currentRow++;

                // Display global filters
                const globalFilterText = MappingFormatter.formatFilters(filters.global);
                const globalFilterRow = worksheet.getRow(currentRow);
                globalFilterRow.getCell(1).value = `Global Filters: ${globalFilterText}`;
                worksheet.mergeCells(currentRow, 1, currentRow, 7);
                currentRow++;

                // Display event-specific filters
                const eventFilters = filters.eventSpecific[eventType] || [];
                const eventFilterText = MappingFormatter.formatFilters(eventFilters);
                const eventFilterRow = worksheet.getRow(currentRow);
                eventFilterRow.getCell(1).value = `Event Filters: ${eventFilterText}`;
                worksheet.mergeCells(currentRow, 1, currentRow, 7);
                currentRow += 2; // Add blank row

                // SECTION 2: EVENT-SPECIFIC MAPPINGS
                const mappingHeader = worksheet.getRow(currentRow);
                mappingHeader.getCell(1).value = 'EVENT-SPECIFIC MAPPINGS (apply only to this event)';
                mappingHeader.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1C1134' } };
                mappingHeader.getCell(1).font = { color: { argb: 'FFFFFFFF' }, bold: true, size: 12 };
                mappingHeader.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
                worksheet.mergeCells(currentRow, 1, currentRow, 7);
                currentRow++;

                // Add mapping table headers
                this.addMappingTableHeaders(worksheet, currentRow, aiEnabled);
                currentRow++;

                // Add event-specific mapping data with AI descriptions
                for (let i = 0; i < mappings.length; i++) {
                    currentRow = await this.addMappingRow(worksheet, currentRow, mappings[i], i, mappings.length);
                }
                currentRow += 2; // Add blank rows

                // SECTION 3: GLOBAL MAPPINGS
                const globalHeader = worksheet.getRow(currentRow);
                globalHeader.getCell(1).value = 'GLOBAL MAPPINGS (apply to ALL events)';
                globalHeader.getCell(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1C1134' } };
                globalHeader.getCell(1).font = { color: { argb: 'FFFFFFFF' }, bold: true, size: 12 };
                globalHeader.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
                worksheet.mergeCells(currentRow, 1, currentRow, 7);
                currentRow++;

                // Add mapping table headers
                this.addMappingTableHeaders(worksheet, currentRow, aiEnabled);
                currentRow++;

                // Add global mapping data with AI descriptions
                const totalMappings = mappings.length + globalMappings.length;
                for (let i = 0; i < globalMappings.length; i++) {
                    currentRow = await this.addMappingRow(worksheet, currentRow, globalMappings[i], mappings.length + i, totalMappings);
                }
            }

            addMappingTableHeaders(worksheet, rowIndex, aiEnabled) {
                const descriptionHeader = aiEnabled ? 'Description (AI Generated)' : 'Description';
                const headers = ['Output Key', 'Input Key', 'Transforms', 'Enrichments', 'Defaults', descriptionHeader, 'Playbook'];
                const headerRow = worksheet.getRow(rowIndex);

                headers.forEach((header, idx) => {
                    const cell = headerRow.getCell(idx + 1);
                    cell.value = header;
                    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1C1134' } };
                    cell.font = { color: { argb: 'FFFFFFFF' }, bold: true, size: 11 };
                    cell.alignment = { horizontal: 'center', vertical: 'middle' };
                    cell.border = {
                        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                    };
                });
            }

            async addMappingRow(worksheet, rowIndex, mappingData, currentIndex, totalCount) {
                const playbook = mappingData.playbook;
                const mapping = mappingData.mapping;

                let inputKey = mapping.inputKey || '';
                const outputKey = mapping.outputKey || '';

                // Handle enrichment-only mappings
                if (!inputKey && mapping.staticString !== undefined) {
                    inputKey = '(enrichment)';
                }

                // Handle "input" key
                if (inputKey === 'input') {
                    inputKey = 'input: see transform';
                }

                const transforms = MappingFormatter.formatTransforms(mapping);
                const enrichments = MappingFormatter.formatEnrichments(mapping);
                const defaults = MappingFormatter.formatDefaults(mapping);

                // Generate AI description
                const description = await AIDescriptionGenerator.generateDescription(mappingData);

                // Update progress
                updateProgress(currentIndex + 1, totalCount);

                const row = worksheet.getRow(rowIndex);
                row.getCell(1).value = outputKey;
                row.getCell(2).value = inputKey;
                row.getCell(3).value = transforms;
                row.getCell(4).value = enrichments;
                row.getCell(5).value = defaults;
                row.getCell(6).value = description;
                row.getCell(7).value = playbook;

                // Style data cells
                for (let i = 1; i <= 7; i++) {
                    const cell = row.getCell(i);
                    cell.border = {
                        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                    };
                    cell.alignment = { vertical: 'top', wrapText: true };
                }

                return rowIndex + 1;
            }

            async generate() {
                return await this.workbook.xlsx.writeBuffer();
            }
        }

        // Progress tracking
        function updateProgress(current, total) {
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const progressLabel = document.getElementById('progressLabel');

            if (document.getElementById('aiEnabled').checked && total > 0) {
                progressContainer.classList.add('active');
                const percent = Math.round((current / total) * 100);
                progressFill.style.width = `${percent}%`;
                progressFill.textContent = `${percent}%`;
                progressLabel.textContent = `Generating descriptions... ${current}/${total} mappings`;
            }
        }

        function hideProgress() {
            const progressContainer = document.getElementById('progressContainer');
            progressContainer.classList.remove('active');
            document.getElementById('progressFill').style.width = '0%';
        }

        // File Processing
        async function processFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();

                reader.onload = async (e) => {
                    try {
                        // Get custom playbook name from input field
                        const customName = document.getElementById('playbookNameInput').value.trim() || null;

                        const yamlContent = e.target.result;
                        const parser = new PlaybookParser(file.name, yamlContent, customName);
                        const mappings = parser.extractMappings();
                        const filters = parser.extractFilters();
                        const globalMappings = parser.extractGlobalMappings();

                        // Organize by event type
                        const eventData = {};
                        mappings.forEach(mappingData => {
                            const eventType = mappingData.event_type;
                            if (!eventData[eventType]) {
                                eventData[eventType] = [];
                            }
                            eventData[eventType].push(mappingData);
                        });

                        // Generate Excel with README first
                        const generator = new ExcelGenerator();
                        generator.createReadmeSheet();
                        generator.createSummarySheet(eventData);

                        // Process event sheets with progress tracking
                        const eventTypes = Object.keys(eventData).sort().filter(
                            eventType => eventType !== 'GLOBAL (All Events)' && eventType !== 'DEFAULT (Unmapped Events)'
                        );

                        // Check if AI descriptions are enabled
                        const aiEnabled = document.getElementById('aiEnabled').checked;

                        for (const eventType of eventTypes) {
                            await generator.createEventSheet(eventType, eventData[eventType], filters, globalMappings, aiEnabled);
                        }

                        hideProgress();

                        const excelBuffer = await generator.generate();
                        const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

                        resolve({
                            success: true,
                            filename: file.name,
                            playbook: parser.playbookName,
                            eventCount: Object.keys(eventData).length,
                            mappingCount: mappings.length,
                            events: Object.keys(eventData).sort(),
                            blob: blob,
                            outputFilename: `playbook_dictionary_${parser.playbookName.replace(/[^a-zA-Z0-9]/g, '_')}_AI.xlsx`
                        });
                    } catch (error) {
                        hideProgress();
                        reject({
                            success: false,
                            filename: file.name,
                            error: error.message
                        });
                    }
                };

                reader.onerror = () => {
                    hideProgress();
                    reject({
                        success: false,
                        filename: file.name,
                        error: 'Failed to read file'
                    });
                };

                reader.readAsText(file);
            });
        }

        function displayResult(result) {
            const resultsDiv = document.getElementById('results');
            const resultElement = document.createElement('div');
            resultElement.className = 'file-result';

            if (result.success) {
                resultElement.innerHTML = `
                    <div class="file-result-header">
                        <div class="file-name">${result.filename}</div>
                        <div class="status success">‚úì Success</div>
                    </div>
                    <div class="preview-info">
                        <div class="preview-stat">
                            <div class="preview-stat-label">Playbook Name</div>
                            <div class="preview-stat-value" style="font-size: 18px;">${result.playbook}</div>
                        </div>
                        <div class="preview-stat">
                            <div class="preview-stat-label">Event Types</div>
                            <div class="preview-stat-value">${result.eventCount}</div>
                        </div>
                        <div class="preview-stat">
                            <div class="preview-stat-label">Total Mappings</div>
                            <div class="preview-stat-value">${result.mappingCount}</div>
                        </div>
                    </div>
                    <div class="event-list">
                        <div class="event-list-title">Events in this playbook:</div>
                        <div class="event-tags">
                            ${result.events.map(e => `<span class="event-tag">${e}</span>`).join('')}
                        </div>
                    </div>
                    <button class="btn" onclick="downloadFile('${result.outputFilename}', ${resultsDiv.children.length})" style="margin-top: 20px;">
                        Download Excel File
                    </button>
                `;

                // Store blob for download
                resultElement.dataset.blobIndex = window.resultBlobs ? window.resultBlobs.length : 0;
                if (!window.resultBlobs) window.resultBlobs = [];
                window.resultBlobs.push({ blob: result.blob, filename: result.outputFilename });
            } else {
                resultElement.innerHTML = `
                    <div class="file-result-header">
                        <div class="file-name">${result.filename}</div>
                        <div class="status error">‚úó Error</div>
                    </div>
                    <div class="error-message">
                        ${result.error}
                    </div>
                `;
            }

            resultsDiv.appendChild(resultElement);
        }

        function downloadFile(filename, index) {
            const blobData = window.resultBlobs[index];
            const url = URL.createObjectURL(blobData.blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = blobData.filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function handleFiles(files) {
            const resultsSection = document.getElementById('resultsSection');
            const resultsDiv = document.getElementById('results');
            const clearBtn = document.getElementById('clearBtn');

            resultsSection.classList.add('active');
            clearBtn.style.display = 'inline-block';

            for (const file of files) {
                if (file.name.endsWith('.yaml') || file.name.endsWith('.yml')) {
                    try {
                        const result = await processFile(file);
                        displayResult(result);
                    } catch (error) {
                        displayResult(error);
                    }
                }
            }
        }

        function clearResults() {
            const resultsDiv = document.getElementById('results');
            const resultsSection = document.getElementById('resultsSection');
            const clearBtn = document.getElementById('clearBtn');

            resultsDiv.innerHTML = '';
            resultsSection.classList.remove('active');
            clearBtn.style.display = 'none';
            window.resultBlobs = [];
            hideProgress();
        }

        // Drag and Drop Handlers
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');

        dropzone.addEventListener('click', () => {
            fileInput.click();
        });

        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('drag-over');
        });

        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('drag-over');
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('drag-over');

            const files = Array.from(e.dataTransfer.files);
            handleFiles(files);
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            handleFiles(files);
            e.target.value = ''; // Reset input
        });
    </script>
</body>
</html>
